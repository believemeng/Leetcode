{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Leetcode1.1. Easy1.2. Medium1.3. Hard1. Leetcode 若您是通过PC端Chrome浏览器浏览github页面，推荐安装Chrome插件MathJax Plugin for Github以支持渲染latex公式。 对应的gitbook:point_right:https://wangzhebufangqi.github.io/Leetcode 每日一题 + 随机写题 1.1. Easy # 1 两数之和 7 整数反转 9 回文数 13 罗马数字转整数 14 最长公共前缀 20 有效的括号 21 合并两个有序链表 26 删除排序数组中的重复项 27 移除元素 28 实现strStr 35 搜索插入位置 38 外观数列.md 53 最大子序和 58 最后一个单词的长度 66 加一 67 二进制求和 69 x的平方根 70 爬楼梯 83 删除链表中的重复元素 88 合并两个有序数组 100 相同的树 101 对称二叉树 104 二叉树的最大深度 107 二叉树的层次遍历 108 将有序数组转换为二叉搜索树 110 平衡二叉树 111 二叉树的最小深度 118 杨辉三角 204 计数质数 217 存在重复元素 242 有效的字母异位词 283 移动零 860 柠檬水找零 976 三角形的最大周长 1030 距离顺序排列矩阵单元格 1122 数组的相对排序 1370 上升下降字符串 1.2. Medium # 2 两数相加 3 无重复字符的最长子串 5 最长回文子串 34 在排序数组中查找元素的第一个和最后一个位置 49 字母异位词分组 50 Pow(x, n) 62 不同路径 222 完全二叉树的结点个数 316 去除重复字母 328 奇偶链表 402 移掉K位数字 406 根据身高重建队列 452 用最少数量的箭引爆气球 454 四数相加 II 649 Dota2 参议院 659 分割数组为连续子序列 767 重构字符串 1.3. Hard # 164 最大间距 321 拼接最大数 By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/":{"url":"My Solution/Easy/","title":"Easy","keywords":"","body":"Easy problem of Leetcode. By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/1 两数之和.html":{"url":"My Solution/Easy/1 两数之和.html","title":"1 两数之和","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. C++3.2. Java3.3. python4. 知识点1. 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 1、暴力解法，遍历两遍即可。对于数组nums中的每一个数num[i]，在[i+1,len-1]中寻找是否存在数target-num[i]。 2、考虑用数据结构优化。每遍历到数组中的一个数num[i]，在一个map中查找是否存在target-num[i]，若存在则成功返回；若不存在则将其保存到该map中，等待后面的数操作。利用C++STL中的map，其find复杂度为O(log(n))。 3、再次优化，利用哈希表使得查询操作逼近O(1)。C++中可直接利用STL中的unordered_map。 3. 代码 3.1. C++ class Solution { public: vector twoSum(vector& nums, int target) { unordered_map buf; vector ans; int len=nums.size(); for(int i=0;i 3.2. Java class Solution { public int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); int len = nums.length; for(int i=0;i 3.3. python class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: dic = {} for i,m in enumerate(nums): if dic.get(m) is not None: return [dic.get(m),i] dic[target-m]=i; 4. 知识点 C++ unordered_map STL——map/unordered_map基础用法 唠唠数据结构——哈希表 By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/100 相同的树.html":{"url":"My Solution/Easy/100 相同的树.html","title":"100 相同的树","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/same-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 递归判断即可。 3. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(!p&&!q) return true; else if(p&&!q) return false; else if(q&&!p) return false; else if(p->val!=q->val) return false; else return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right); } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/101 对称二叉树.html":{"url":"My Solution/Easy/101 对称二叉树.html","title":"101 对称二叉树","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 如果同时满足下面的条件，两个树互为镜像： 它们的两个根结点具有相同的值 每个树的右子树都与另一个树的左子树镜像对称 3. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool helper(TreeNode* p, TreeNode* q){ if(!p&&!q) return true; else if(p&&!q) return false; else if(q&&!p) return false; else if(p->val!=q->val) return false; else return helper(p->left,q->right)&&helper(p->right,q->left); } bool isSymmetric(TreeNode* root) { return helper(root,root); } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/1030 距离顺序排列矩阵单元格.html":{"url":"My Solution/Easy/1030 距离顺序排列矩阵单元格.html","title":"1030 距离顺序排列矩阵单元格","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. sort排序3.2. 桶排序1. 题目 给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。 返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。） 示例 1： 输入：R = 1, C = 2, r0 = 0, c0 = 0 输出：[[0,0],[0,1]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1] 示例 2： 输入：R = 2, C = 2, r0 = 0, c0 = 1 输出：[[0,1],[0,0],[1,1],[1,0]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2] [[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。 示例 3： 输入：R = 2, C = 3, r0 = 1, c0 = 2 输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3] 其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/matrix-cells-in-distance-order 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 一开始直接用的sort排序 数据规模不大，可以用桶排序 这题还可以用BFS，但时间性能并没有改善，就不写了 3. 代码 3.1. sort排序 class Solution { public: int dis(int r0, int c0,int r, int c){ return abs(r0-r)+abs(c0-c); } vector> allCellsDistOrder(int R, int C, int r0, int c0) { vector> res; for(int i=0;i& a, vector&b){ return dis(r0,c0,a[0],a[1]) 3.2. 桶排序 class Solution { public: const static int MAXR = 100; const static int MAXC = 100; int dis(int r0, int c0,int r, int c){ return abs(r0-r)+abs(c0-c); } vector> allCellsDistOrder(int R, int C, int r0, int c0) { vector> res; vector> bucket[MAXC+MAXR]; for(int i=0;i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/104 二叉树的最大深度.html":{"url":"My Solution/Easy/104 二叉树的最大深度.html","title":"104 二叉树的最大深度","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 基础题 3. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if(!root) return 0; return 1+max(maxDepth(root->left),maxDepth(root->right)); } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/107 二叉树的层次遍历.html":{"url":"My Solution/Easy/107 二叉树的层次遍历.html","title":"107 二叉树的层次遍历","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 利用队列 二叉树的层次遍历 3. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector> levelOrderBottom(TreeNode* root) { vector > res; if(!root) return res; queue Q; Q.push(root); while(!Q.empty()){ int sz = Q.size(); vector vec; TreeNode* tn; while(sz--){ tn = Q.front(); Q.pop(); if(tn->left) Q.push(tn->left); if(tn->right) Q.push(tn->right); vec.push_back(tn->val); } res.insert(res.begin(),vec); } return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/108 将有序数组转换为二叉搜索树.html":{"url":"My Solution/Easy/108 将有序数组转换为二叉搜索树.html","title":"108 将有序数组转换为二叉搜索树","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。 递归即可 3. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* sortedArrayToBST(vector& nums) { int len = nums.size(); if(len==0) return nullptr; if(len==1) return new TreeNode(nums[0]); TreeNode* head = new TreeNode(nums[len/2]); vector leftArray(nums.begin(),nums.begin()+len/2); vector rightArray(nums.begin()+len/2+1,nums.end()); head->left = sortedArrayToBST(leftArray); head->right = sortedArrayToBST(rightArray); return head; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/110 平衡二叉树.html":{"url":"My Solution/Easy/110 平衡二叉树.html","title":"110 平衡二叉树","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 1.03.2. 2.03.3. 3.01. 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/balanced-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 这题做的太曲折了。一开始定义没整明白，做了很多无用功。后来明确题意了，又因为以前做过的一道题陷入了思维定式，做的非常复杂。 明确题意： 它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树 明确题意就好做了 3. 代码 3.1. 1.0 黑历史，这版代码写的又臭又长 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool help(TreeNode* L,TreeNode* R){ if(!L&&!R) return true; else if(L&&!R){ if(L->left||L->right) return false; else return true; }else if(!L&&R){ if(R->left||R->right) return false; else return true; } else { bool flag = help(L->left,L->right) && help(R->left,R->right); if(L->left && !L->right) flag = flag && (help(L->left,R->left) || help(L->left,R->right)); else if(L->right && !L->left) flag = flag && (help(L->right,R->left) || help(L->right,R->right)); else if(!L->left && !L->right) flag = flag && (help(L->left,R->left) && help(L->left,R->right) ); else if(L->left && L->right) flag = flag && (help(L->left,R->left) || help(L->left,R->right) || help(L->right,R->left) || help(L->right,R->right)); if(!R->left && !R->right) flag = flag &&(help(L->left,R->left) && help(L->right,R->left)); return flag; } } bool isBalanced(TreeNode* root) { if(!root) return true; return help(root->left,root->right); } }; 3.2. 2.0 这版递归，重复计算了很多东西。可以改进为提前判断。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxHeight(TreeNode* root){ if(!root) return 0; return max(maxHeight(root->left),maxHeight(root->right))+1; } bool isBalanced(TreeNode* root) { if(!root) return true; return isBalanced(root->left) && isBalanced(root->right) && abs(maxHeight(root->left)-maxHeight(root->right)) 3.3. 3.0 但是，貌似时间性能并没有改善 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int height(TreeNode* root){ if(!root) return 0; int leftHeight = height(root->left); if(leftHeight == -1) return -1; int rightHeight = height(root->right); if(rightHeight == -1) return -1; if(abs(leftHeight-rightHeight)>1) return -1; return max(leftHeight,rightHeight)+1; } bool isBalanced(TreeNode* root) { return height(root)>=0; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/111 二叉树的最小深度.html":{"url":"My Solution/Easy/111 二叉树的最小深度.html","title":"111 二叉树的最小深度","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 注意判别叶子结点 3. 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { if(!root) return 0; if(!root->left && !root->right) return 1;//叶子结点 int res = 100001; if(root->left) res = min(res,minDepth(root->left)); if(root->right) res = min(res,minDepth(root->right)); return res+1; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/1122 数组的相对排序.html":{"url":"My Solution/Easy/1122 数组的相对排序.html","title":"1122 数组的相对排序","keywords":"","body":"1. 题目2. 解题思路2.1. 自定义排序2.2. 计数排序3. 代码3.1. 自定义排序3.2. 计数排序1. 题目 给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/relative-sort-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 2.1. 自定义排序 若arr1中元素在arr2中出现过，则增添一个位置信息pos；若未出现过，pos设为最大值。 排序时先按pos排，再按值val排即可 2.2. 计数排序 该题就是一个桶排序，先把arr2中的数按顺序拿完，在把桶中剩下的按顺序拿完 3. 代码 3.1. 自定义排序 class Solution { public: struct node{ int val; int pos; node(int v,int p){ val=v,pos=p; } bool operator relativeSortArray(vector& arr1, vector& arr2) { vector Arr; unordered_map table; for(int i=0;i 看官方题解时，发现可以写的更简单，比如那个结构体不必显式定义出来 可惜的是时间性能并没有改善，甚至比我上面的代码还慢 官方题解： class Solution { public: vector relativeSortArray(vector& arr1, vector& arr2) { unordered_map table; for(int i=0;i 在sort函数里直接定义排序规则，这种写法我也是第一次在C++里碰见，没找到相关资料，期待后续能学习到。 3.2. 计数排序 class Solution { public: vector relativeSortArray(vector& arr1, vector& arr2) { vector ans; map table; for(auto &x:arr1) table[x]++; for(auto &x:arr2) while(table[x]--) ans.push_back(x); for(auto &x:table) while(x.second-->0) ans.push_back(x.first); return ans; } }; 用map替代unordered_map，是因为map中元素默认排序方法为按first升序 By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/118 杨辉三角.html":{"url":"My Solution/Easy/118 杨辉三角.html","title":"118 杨辉三角","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 模拟即可 3. 代码 class Solution { public: vector> generate(int numRows) { vector> res; if(!numRows) return res; if(numRows==1) return {{1}}; res.push_back({1}); for(int i=1;i tmp; tmp.push_back(1); for(int j=1;j By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/13 罗马数字转整数.html":{"url":"My Solution/Easy/13 罗马数字转整数.html","title":"13 罗马数字转整数","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. AC代码1. 题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/roman-to-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 注意这句话：通常情况下，罗马数字中小的数字在大的数字的右边 因此只要比较两个相邻的字母（数字） 如果右边的数字小（级别低）于左边的数字，则说明是通常情况，加上对应的值即可； 如果右边的数字大（级别高）于左边的数字，则是特殊情况（共六种），特殊处理即可。注意，每次特殊情况仅涉及到2个数字。 （后面看题解才注意到，这里的情况是： 通常情况 加，特殊情况 减。如：IV = 5-1 =4，VI= 5+1 =6。 ） 3. 代码 3.1. AC代码 写复杂了。但范围更广。 class Solution { public: int getLevel(char c){ if(c=='I') return 1; else if(c=='V'||c=='X') return 2; else if(c=='L'||c=='C') return 3; else if(c=='D'||c=='M') return 4; return 0; } int getValue(char c){//normal case int res=0; switch (c){ case 'I':res=1;break; case 'V':res=5;break; case 'X':res=10;break; case 'L':res=50;break; case 'C':res=100;break; case 'D':res=500;break; case 'M':res=1000;break; } return res; } int getSpecialValue(char a,char b){//when a's level =getLevel(s[i+1])) res+=getValue(s[i]); else res+=getSpecialValue(s[i],s[i+1]),i++; } return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/1370 上升下降字符串.html":{"url":"My Solution/Easy/1370 上升下降字符串.html","title":"1370 上升下降字符串","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给你一个字符串 s ，请你根据下面的算法重新构造字符串： 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。 请你返回将 s 中字符重新排序后的 结果字符串 。 示例 1： 输入：s = \"aaaabbbbcccc\" 输出：\"abccbaabccba\" 解释：第一轮的步骤 1，2，3 后，结果字符串为 result = \"abc\" 第一轮的步骤 4，5，6 后，结果字符串为 result = \"abccba\" 第一轮结束，现在 s = \"aabbcc\" ，我们再次回到步骤 1 第二轮的步骤 1，2，3 后，结果字符串为 result = \"abccbaabc\" 第二轮的步骤 4，5，6 后，结果字符串为 result = \"abccbaabccba\" 示例 2： 输入：s = \"rat\" 输出：\"art\" 解释：单词 \"rat\" 在上述算法重排序以后变成 \"art\" 示例 3： 输入：s = \"leetcode\" 输出：\"cdelotee\" 示例 4： 输入：s = \"ggggggg\" 输出：\"ggggggg\" 示例 5： 输入：s = \"spo\" 输出：\"ops\" 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/increasing-decreasing-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 水题。用a[i]表示字符a+'i'的个数。 3. 代码 class Solution { public: string sortString(string s) { string res; int a[26]; fill(a,a+26,0); for(auto &x:s) a[x-'a']++; bool remain = true; while(remain){ remain = false; for(int i = 0;i = 0; --i){ if(a[i]) remain = true, res.push_back(char('a'+i)),a[i]--; } } return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/14 最长公共前缀.html":{"url":"My Solution/Easy/14 最长公共前缀.html","title":"14 最长公共前缀","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 横向扫描3.2. 纵向扫描3.3. 不完全排序1. 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 1、横向扫描 n个字符串，每次遍历比较2个字符串，一直更新最长公共前缀 2、纵向扫描 遍历所有字符串的第i个字符，寻找最先找不到相同字符的位置即可 3、分治 分治主要利用了 LCP(Si,...,Sj)=LCP(LCP(Si,...,Smid),LCP(Smid,...,Sj)) LCP(S_i,...,S_j)=LCP(LCP(S_i,...,S_{mid}),LCP(S_{mid},...,S_j)) LCP(Si​,...,Sj​)=LCP(LCP(Si​,...,Smid​),LCP(Smid​,...,Sj​)) 对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即为原问题的解。 时间复杂度没有大的改善 4、二分 设公共最长前缀长度为x，如果x满足，则真正的公共最长公共前缀一定大于x；如果x不满足，则真正的公共最长前缀一定小于x。 所以可用二分 可惜时间复杂度还多了个logm，m为字符串数组中的字符串的最小长度 5、不完全排序 题目比较特殊，只要找到字典序最大和最小的求最长公共前缀即可 3. 代码 3.1. 横向扫描 class Solution { public: string longestCommonPrefix(vector& strs) { int size = strs.size(); if(size==1) return strs[0]; string res; int maxlen=(1 一开始没注意strs可能是空的，直接用strs[0]会报错。 3.2. 纵向扫描 class Solution { public: string longestCommonPrefix(vector& strs) { int size = strs.size(); if(size==0) return \"\"; string res; int maxlen=0; for(int i=0;i 3.3. 不完全排序 class Solution { public: string longestCommonPrefix(vector& strs) { if(strs.empty()) return \"\"; auto p=minmax_element(strs.begin(),strs.end()); string res = *p.first; for(int i=0;isize();++i){ if(p.first->at(i)!=p.second->at(i)){ res = p.first->substr(0,i); return res; } } return res; } }; 学会了\\文件里的minmax和minmax_element函数。minmax函数返回最小值和最大值的pair对。minmax_element函数返回最小值和最大值的迭代器的pair对。时间都为线性时间。 By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/20 有效的括号.html":{"url":"My Solution/Easy/20 有效的括号.html","title":"20 有效的括号","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 栈的简单应用。括号匹配。 官方题解中用哈希表中的一个键值对存储一对匹配的括号。挺好的表示方法。能减少后续一定量的代码量。 unordered_map pairs = { {')', '('}, {']', '['}, {'}', '{'} }; 3. 代码 class Solution { public: bool isValid(string s) { stack tmp; for(auto ch:s){ if(!tmp.empty()){ switch (ch){ case ')': if(tmp.top()=='(') tmp.pop(); else return false; break; case ']': if(tmp.top()=='[') tmp.pop(); else return false; break; case '}': if(tmp.top()=='{') tmp.pop(); else return false; break; default: tmp.push(ch); break; } } else tmp.push(ch); } if(tmp.empty()) return true; else return false; } }; 看到了一种比较巧妙的写法： class Solution { public boolean isValid(String s) { LinkedList stack = new LinkedList<>(); for (char c : s.toCharArray()) { if (c == '[') stack.push(']'); else if (c == '(') stack.push(')'); else if (c == '{') stack.push('}'); else if (stack.isEmpty() || c != stack.pop()) return false; } return stack.isEmpty(); } } By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/204 计数质数.html":{"url":"My Solution/Easy/204 计数质数.html","title":"204 计数质数","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 埃氏筛3.2. 线性筛1. 题目 统计所有小于非负整数 n 的质数的数量。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2： 输入：n = 0 输出：0 示例 3： 输入：n = 1 输出：0 提示： 0≤n≤5∗1060 \\leq n \\leq 5 * 10^60≤n≤5∗106 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-primes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 没什么好说的，埃氏筛、线性筛（欧拉筛） 3. 代码 3.1. 埃氏筛 class Solution { public: int countPrimes(int n) { int ans = 0; if(n isPrime(n+1,1); isPrime[0]=0, isPrime[1]=0; for(int i=2; i 3.2. 线性筛 class Solution { public: int countPrimes(int n) { if(n isPrime(n+1,1); vector primes; isPrime[0]=0, isPrime[1]=0; int ans; for(int i=2; i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/21 合并两个有序链表.html":{"url":"My Solution/Easy/21 合并两个有序链表.html","title":"21 合并两个有序链表","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 创建新结点3.2. 不创建新结点1. 题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 遍历可以解决。 可以用递归写法。 3. 代码 递归： 3.1. 创建新结点 这种一开始容易想到 class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* res = new ListNode(); if(l1==NULL) res=l2; else if(l2==NULL) res=l1; else{ if(l1->val>l2->val) { res=l2; res->next=mergeTwoLists(l1,l2->next); } else { res=l1; res->next=mergeTwoLists(l1->next,l2); } } return res; } }; 3.2. 不创建新结点 这种比起创建新结点省时间省空间 class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==NULL) return l2; else if(l2==NULL) return l1; else{ if(l1->val>l2->val) { l2->next=mergeTwoLists(l1,l2->next); return l2; } else { l1->next=mergeTwoLists(l1->next,l2); return l1; } } } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/217 存在重复元素.html":{"url":"My Solution/Easy/217 存在重复元素.html","title":"217 存在重复元素","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 水题。利用set去重即可。 3. 代码 class Solution { public: bool containsDuplicate(vector& nums) { set S(nums.begin(),nums.end()); return S.size()==nums.size()?false:true; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/242 有效的字母异位词.html":{"url":"My Solution/Easy/242 有效的字母异位词.html","title":"242 有效的字母异位词","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true 示例 2: 输入: s = \"rat\", t = \"car\" 输出: false 说明: 你可以假设字符串只包含小写字母。 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-anagram 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 排个序就行，O(nlogn)。 或者用Hash，O(n)。 3. 代码 #define ull unsigned long long const int B = 1e9+7; class Solution { public: int bs[26],bt[26]; ull getHash(int *b){ ull res = 0; for(int i=0;i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/26 删除排序数组中的重复项.html":{"url":"My Solution/Easy/26 删除排序数组中的重复项.html","title":"26 删除排序数组中的重复项","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 双指针。 3. 代码 class Solution { public: int removeDuplicates(vector& nums) { int len=nums.size(); if(len==0||len==1) return len; int s=0,e=1; while(e 一开始执行错误，碰到了这样的报错： AddressSanitizer: heap-buffer-overflow on address 0x602000000338 at pc 0x0000003b5051 bp 0x7fff15373c60 sp 0x7fff15373c58 字面意思是堆缓存溢出。 我这里发现是数组越界。一开始有情况访问到了nums[len]，而nums的最后一个元素应该是nums[len-1]。 官方的： public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; for (int j = 1; j 和27 移除元素很相似。 By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/27 移除元素.html":{"url":"My Solution/Easy/27 移除元素.html","title":"27 移除元素","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-element 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 双指针。方法和26 删除排序数组中的重复项差不多。 3. 代码 class Solution { public: int removeElement(vector& nums, int val) { int len=nums.size(); int s=0,e=0; while(s 我的思路侧重在慢指针，数组中每出现一个val值，急着用快指针从后面找到一个不是val的值。 官方用快指针遍历一次，在后面碰到一个不是val的值时，才考虑放在用慢指针计数的前面。 官方的：看起来优雅简洁很多 public int removeElement(int[] nums, int val) { int i = 0; for (int j = 0; j By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/28 实现strStr.html":{"url":"My Solution/Easy/28 实现strStr.html","title":"28 实现strStr","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. KMP3.2. HASH1. 题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = \"hello\", needle = \"ll\" 输出: 2 示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/implement-strstr 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 看到这题第一反应就是kmp 冷落了hash，唉 3. 代码 3.1. KMP class Solution { public: const static int MAXN=1e5+5; int Next[MAXN]; void getNext(string needle){ int k=Next[0]=-1; int len=needle.size(),j=0; while(j 3.2. HASH 滚动哈希。近似与官方题解中提到的Rabin-Karp算法。 #define ull unsigned long long class Solution { public: const static ull B = 1e9+7; int strStr(string haystack, string needle) { int lenH=haystack.size(),lenN=needle.size(); if(lenN==0) return 0; ull t=1,hashH=0,hashN=0; for(int i=1;i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/283 移动零.html":{"url":"My Solution/Easy/283 移动零.html","title":"283 移动零","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/move-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 3. 代码 class Solution { public: void moveZeroes(vector& nums) { int len = nums.size(); int cnt = 0;//current num of zero int first_zero = -1; for(int i=0;i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/35 搜索插入位置.html":{"url":"My Solution/Easy/35 搜索插入位置.html","title":"35 搜索插入位置","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 遍历3.2. 二分3.2.1. 左开右开3.2.2. 左闭右开3.2.3. 左闭右闭1. 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 第一眼，遍历。再看一眼，二分。 3. 代码 3.1. 遍历 class Solution { public: int searchInsert(vector& nums, int target) { for(int i=0;i=target) return i; } return nums.size(); } }; 3.2. 二分 以下三种解法中，此题中速度最快的为左闭右闭。 3.2.1. 左开右开 class Solution { public: int searchInsert(vector& nums, int target) { int left=-1,right=nums.size(),mid; while(left+1!=right){ mid=(left+right)>>1; if(nums[mid]>target) right=mid; else if(nums[mid] 3.2.2. 左闭右开 class Solution { public: int searchInsert(vector& nums, int target) { int left=0,right=nums.size(),mid; while(left>1; if(nums[mid]>target) right=mid; else if(nums[mid] 3.2.3. 左闭右闭 class Solution { public: int searchInsert(vector& nums, int target) { int left=0,right=nums.size()-1,mid; while(left>1; if(nums[mid]>target) right=mid-1; else if(nums[mid] By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/38 外观数列.html":{"url":"My Solution/Easy/38 外观数列.html","title":"38 外观数列","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 你可以将其视作是由递归公式定义的数字字符串序列： countAndSay(1) = \"1\" countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下： 1 11 21 1211 111221 第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\" 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\" 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \"1211\" 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"111221\" 要描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 例如，数字字符串 \"3322251\" 的描述如下图： 示例 1： 输入：n = 1 输出：\"1\" 解释：这是一个基本样例。 示例 2： 输入：n = 4 输出：\"1211\" 解释： countAndSay(1) = \"1\" countAndSay(2) = 读 \"1\" = 一 个 1 = \"11\" countAndSay(3) = 读 \"11\" = 二 个 1 = \"21\" countAndSay(4) = 读 \"21\" = 一 个 2 + 一 个 1 = \"12\" + \"11\" = \"1211\" 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-and-say 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 数据规模小，模拟。然后打表即可。没什么好写的。 3. 代码 class Solution { public: string countAndSay(int n) { string arr[31] = { \"\",\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" }; return arr[n]; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/53 最大子序和.html":{"url":"My Solution/Easy/53 最大子序和.html","title":"53 最大子序和","keywords":"","body":"1. 题目2. 解题思路2.1. 动态规划2.2. 线段树（分治）3. 代码3.1. 动态规划3.2. 线段树1. 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 2.1. 动态规划 动态规划入门题。 令dp[i]表示以第i个数结尾的连续子数组的最大和，即所求为max⁡0≤i≤n−1dp[i]\\max\\limits_{0\\leq i\\leq n-1}{dp[i]}0≤i≤n−1max​dp[i] 转移方程为dp[i]=max(dp[i−1]+a[i],a[i])dp[i]=max(dp[i-1]+a[i],a[i])dp[i]=max(dp[i−1]+a[i],a[i]) 空间优化之后可以不用数组保存每一个dp[i]的值。 2.2. 线段树（分治） 线段树解决区间问题。 每个结点保存四个值，lSum，rSum，mSum，iSum： lSum 表示 [l, r] 内以 l 为左端点的最大子段和 rSum 表示 [l, r] 内以 r 为右端点的最大子段和 mSum 表示 [l, r] 内的最大子段和 iSum 表示 [l, r] 的区间和 更新信息： 首先最好维护的是 iSum，区间 [l, r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的 iSum。 对于 [l, r]的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」的 iSum 加上「右子区间」的 lSum，二者取大。 对于 [l, r] 的 rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取大。 当计算好上面的三个量之后，就很好计算 [l, r] 的 mSum 了。我们可以考虑 [l, r] 的 mSum 对应的区间是否跨越 mm——它可能不跨越 mm，也就是说 [l, r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 mm，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。 3. 代码 3.1. 动态规划 class Solution { public: int maxSubArray(vector& nums) { int res=nums[0],t=0; for(int i=0;i 3.2. 线段树 const int MAXN=1e4+5; #define ls(p) (p>1; T[p].iSum=T[ls(p)].iSum+T[rs(p)].iSum; T[p].lSum=max(T[ls(p)].lSum,T[ls(p)].iSum+T[rs(p)].lSum); T[p].rSum=max(T[rs(p)].rSum,T[rs(p)].iSum+T[ls(p)].rSum); T[p].mSum=max(max(T[rs(p)].mSum,T[ls(p)].mSum),T[ls(p)].rSum+T[rs(p)].lSum); } void build(vector&nums, int p,int l,int r){ if(l==r){ T[p].lSum=T[p].rSum=T[p].mSum=T[p].iSum=nums[l-1]; return; } int mid=(l+r)>>1; build(nums,ls(p),l,mid); build(nums,rs(p),mid+1,r); push_up(p,l,r); } int query(int p,int l,int r,int nl,int nr){ if(nl=r) return T[p].mSum; int res=-(1>1; if(nl& nums) { int n=nums.size(); build(nums,1,1,n); return query(1,1,n,1,n); } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/58 最后一个单词的长度.html":{"url":"My Solution/Easy/58 最后一个单词的长度.html","title":"58 最后一个单词的长度","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 示例: 输入: \"Hello World\" 输出: 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/length-of-last-word 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 水题。从后往前遍历即可，找到字母后的第一个空格。 3. 代码 class Solution { public: int lengthOfLastWord(string s) { int cnt=0; for(int i=s.size()-1;i>=0;--i){ if(s[i]==' '&&cnt) break; if(s[i]!=' ') cnt++; } return cnt; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/66 加一.html":{"url":"My Solution/Easy/66 加一.html","title":"66 加一","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/plus-one 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 水题。 3. 代码 class Solution { public: vector plusOne(vector& digits) { vector res; int carry=1; vector::reverse_iterator rit=digits.rbegin(); for(;rit!=digits.rend();++rit){ carry=*rit+carry; res.push_back(carry%10); carry=carry/10; } if(carry) res.push_back(carry); reverse(res.begin(),res.end()); return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/67 二进制求和.html":{"url":"My Solution/Easy/67 二进制求和.html","title":"67 二进制求和","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\" 输出: \"100\" 示例 2: 输入: a = \"1010\", b = \"1011\" 输出: \"10101\" 提示： 每个字符串仅由字符 '0' 或 '1' 组成。 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-binary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 先将两字符串用前导0补至同一长度，再做加法。 3. 代码 class Solution { public: string addBinary(string a, string b) { string res; int len; if(a.size()>b.size()) { string tmp(a.size()-b.size(),'0'); len=a.size(); b=tmp+b; }else { string tmp(b.size()-a.size(),'0'); len=b.size(); a=tmp+a; } int carry=0,num=0; for(int i=len-1;i>=0;--i){ num=a[i]-'0'+b[i]-'0'+carry; res.push_back((num%2)+'0'); carry=num/2; } if(carry>0) res.push_back('1'); reverse(res.begin(),res.end()); return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/69 x的平方根.html":{"url":"My Solution/Easy/69 x的平方根.html","title":"69 x的平方根","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 公式法3.2. 二分1. 题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sqrtx 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 1、公式法： 「袖珍计算器算法」是一种用指数函数 exp⁡\\expexp 和对数函数 lnlnln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。 x=x12=(eln x)12=e12 ln x \\sqrt{x}=x^{\\frac{1}{2}}=(e^{ln\\ x})^{\\frac{1}{2}}=e^{\\frac{1}{2}\\ ln\\ x} x​=x21​=(eln x)21​=e21​ ln x 需要验算。 2、二分查找。 3、还可以用牛顿迭代，数学渣不看。 3. 代码 3.1. 公式法 class Solution { public: int mySqrt(int x) { if (x == 0) { return 0; } int ans = exp(0.5 * log(x)); return ((long long)(ans + 1) * (ans + 1) 3.2. 二分 class Solution { public: int mySqrt(int x) { long long l=-1,r=(long long)x+1; while(l+1!=r){ long long mid=(l+r)>>1; if(mid*mid class Solution { public: int mySqrt(int x) { long long l = 0, r = x; while (l By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/7 整数反转.html":{"url":"My Solution/Easy/7 整数反转.html","title":"7 整数反转","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. AC代码1. 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,231−1][-2^{31}, 2^{31} − 1][−231,231−1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 没什么特殊的算法。常规方法逆转数字。 注意处理溢出问题。 这里用C++测试的时候，int存储的数据超过2147483647(2^31-1)就会报错。Java不会。 所以需要预判一下。 先考虑正数： int的最大数INT_MAX是2147483647 假设翻转后的数为res，res大于INT_MAX就算溢出 假设上一步的翻转数为res'，进行预判断： res'>214748364，res一定会溢出 res'=214748364，需进一步判断最后一位加进来的数字也就是原数字的第一位，设为top。若top>7，res一定会溢出；否则，不会溢出。 res' 再考虑负数，和正数类似： int的最小数INT_MIN是-2147483648 res' res'=-214748364，需进一步判断最后一位加进来的数字也就是原数字的第一位，设为top。若top res'>-214748364，res不会溢出 3. 代码 1、假设溢出不会报错 class Solution { public: int reverse(int x) { int tmp,ans=0; while(x!=0){ tmp=ans; ans=ans*10+x%10; if(ans/10!=tmp) return 0;//溢出后的值与预想中的值不会相同 x=x/10; } return ans; } }; 3.1. AC代码 2、预判溢出 class Solution { public: int reverse(int x) { int res = 0; while(x!=0){ if(res>214748364 || (res==214748364 && x%10>7)) return 0; if(res By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/70 爬楼梯.html":{"url":"My Solution/Easy/70 爬楼梯.html","title":"70 爬楼梯","keywords":"","body":"1. 题目2. 解题思路2.1. 动态规划2.2. 比内公式2.3. 矩阵快速幂3. 代码3.1. 动态规划3.2. 比内公式3.3. 矩阵快速幂1. 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 2.1. 动态规划 动态规划入门题了。dp[n] = dp[n-1]+dp[n-2]。dp[0]=1，dp[1]=1。 然后发现，这不是斐波那契数列吗？？ 说起斐波那契数列，那解法就多起来了。 2.2. 比内公式 设斐波那契数列为f[i]，f[0]=0，f[1]=1，f[2]=1，f[3]=2，f[4]=3... 则dp[i]=f[i+1] 比内公式： f[n]=15[(1+52)n−(1−52)n] f[n]=\\frac{1}{\\sqrt{5}}[(\\frac{1+\\sqrt{5}}{2})^n-(\\frac{1-\\sqrt{5}}{2})^n] f[n]=5​1​[(21+5​​)n−(21−5​​)n] 2.3. 矩阵快速幂 亦可如下推导： 3. 代码 3.1. 动态规划 下述代码可进行空间优化 class Solution { public: int climbStairs(int n) { vector dp(n+1,1); for(int i=2;i 3.2. 比内公式 class Solution { public: int climbStairs(int n) { double a=(1+sqrt(5))/2; double b=(1-sqrt(5))/2; //精度不够，数据过大可能会有偏差 return (pow(a,n+1)-pow(b,n+1))/sqrt(5);//dp[i]=f[i+1] } }; 3.3. 矩阵快速幂 class Solution { public int[][] times(int[][] a, int[][] b){ int[][] c = new int[2][2]; for(int i=0;i0){ if((y&1)>0) res = times(res,x); x = times(x,x); y>>=1; } return res; } public int climbStairs(int n) { int[][] q = {{1,1},{1,0}}; int[][] ans = quickPower(q,n); return ans[0][0]; } } By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/83 删除链表中的重复元素.html":{"url":"My Solution/Easy/83 删除链表中的重复元素.html","title":"83 删除链表中的重复元素","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1->1->2 输出: 1->2 示例 2: 输入: 1->1->2->3->3 输出: 1->2->3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 排序好的，每次比较前后两个 3. 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if(head==nullptr) return head; ListNode* tmp = head; while(tmp->next!=nullptr){ if(tmp->val==tmp->next->val){ tmp->next=tmp->next->next; } else tmp=tmp->next; } return head; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/860 柠檬水找零.html":{"url":"My Solution/Easy/860 柠檬水找零.html","title":"860 柠檬水找零","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1： 输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 输入：[5,5,10] 输出：true 示例 3： 输入：[10,10] 输出：false 示例 4： 输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lemonade-change 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 按题意模拟即可 3. 代码 class Solution { public: bool lemonadeChange(vector& bills) { int cnt5 = 0, cnt10 = 0, cnt20 = 0; for(auto &x:bills){ switch(x){ case 5: cnt5++; break; case 10: if(cnt5 By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/88 合并两个有序数组.html":{"url":"My Solution/Easy/88 合并两个有序数组.html","title":"88 合并两个有序数组","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明： 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例： 输入： nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 提示： -10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 从头到尾，将最小数的插入到合适的位置即可 排序的没意思 3. 代码 class Solution { public: void merge(vector& nums1, int m, vector& nums2, int n) { int i=0,j=0; while(j By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/9 回文数.html":{"url":"My Solution/Easy/9 回文数.html","title":"9 回文数","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 错误代码3.2. AC代码1. 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 不将整数转为字符串的话，一开始是想用数学方法每次求出首位数字和末尾数字，见错误代码。 所以还是老老实实翻转一半数字吧，这样就不会像全部翻转那样可能溢出。这样也要注意处理特殊情况，末尾数字是0的情况。 3. 代码 3.1. 错误代码 class Solution { public: int getw(int x){//add by myself, get the width of x if(x 可惜忽略了形如1000021等中间含有0的数字。 3.2. AC代码 class Solution { public: bool isPalindrome(int x) { if(xres){ res = 10*res + x%10; x = x/10; } /* 结束循环的时候， 若x==res，则一定是偶数位的回文数； 若x By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Easy/976 三角形的最大周长.html":{"url":"My Solution/Easy/976 三角形的最大周长.html","title":"976 三角形的最大周长","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 示例 1： 输入：[2,1,2] 输出：5 示例 2： 输入：[1,2,1] 输出：0 示例 3： 输入：[3,2,3,4] 输出：10 示例 4： 输入：[3,6,2,3] 输出：8 提示： 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/largest-perimeter-triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 先排序，从最大的开始找，找到即可 3. 代码 class Solution { public: int largestPerimeter(vector& A) { sort(A.begin(),A.end(),greater()); int len = A.size(); for(int i = 0; i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Hard/":{"url":"My Solution/Hard/","title":"Hard","keywords":"","body":"Hard problem of Leetcode. By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Hard/164 最大间距.html":{"url":"My Solution/Hard/164 最大间距.html","title":"164 最大间距","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 示例 1: 输入: [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 说明: 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-gap 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 很显然，排好序遍历一遍即可。线性时间复杂度的排序法为基数排序。虽然其时间复杂度为线性，但是其常数太大了，跑起来竟然和快速排序差不多。 3. 代码 class Solution { public: void countSort(vector& nums, int exp){ vector count(10,0),res(nums.size()); for(auto &x: nums) count[(x/exp)%10]++; partial_sum(count.begin(),count.end(),count.begin()); for(int i=nums.size()-1;i>=0;--i) res[--count[(nums[i]/exp)%10]]=nums[i]; nums.assign(res.begin(),res.end()); } void radixSort(vector& nums){ int range = *max_element(nums.begin(),nums.end()); for(int exp=1;range/exp>0;exp*=10){ countSort(nums,exp); } } int maximumGap(vector& nums) { int len = nums.size(); if(len By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Hard/321 拼接最大数.html":{"url":"My Solution/Hard/321 拼接最大数.html","title":"321 拼接最大数","keywords":"","body":"1. 题目2. 解题思路2.1. 定义子问题2.2. 合并子问题2.3. 求解3. 代码1. 题目 给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k 求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。 说明: 请尽可能地优化你算法的时间和空间复杂度。 示例 1: 输入: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 输出: [9, 8, 6, 5, 3] 示例 2: 输入: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 输出: [6, 7, 6, 0, 4] 示例 3: 输入: nums1 = [3, 9] nums2 = [8, 9] k = 3 输出: [9, 8, 9] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/create-maximum-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 2.1. 定义子问题 给定一个以数组表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最大。（可参考402 移掉k位数字） 对于num[i+1]，若num[i+1]>num[i]，则移除掉num[i]。否则暂时保留。直至移掉k位数字。不足则从末位移除补齐。 借助栈的思想： vector removeKNumber(vector& num, int k){ vector stack; int len = num.size(); for(int i=0;istack.back() && k){ k--; stack.pop_back(); } stack.push_back(num[i]); } while(k--) stack.pop_back(); return stack; } 2.2. 合并子问题 分别得到两个数组中的最大数字后，将两个合并。 两个指针分别指向数组num1和num2的头，每次选数字大的，若是两个数字相等，则需要依次往后比较直至出现不同的数字（这里用\\里的lexicographical_compare函数简化代码，即比较字典序）。 vector mergeTwoNums(vector& num1, vector& num2){ vector ans; auto p1=num1.begin(), p2 = num2.begin(); while(p1!=num1.end() && p2!=num2.end()){ if(*p1 > *p2) ans.push_back(*p1),p1++; else if(*p1 2.3. 求解 总共要选取k个数字构成最大数，考虑从数组nums1中取出数字的个数范围[low,high]，求出每种情况下的最大值。最后取总的最大值即可。 3. 代码 class Solution { public: vector removeKNumber(vector& num, int k){ vector stack; int len = num.size(); for(int i=0;istack.back() && k){ k--; stack.pop_back(); } stack.push_back(num[i]); } while(k--) stack.pop_back(); return stack; } vector mergeTwoNums(vector& num1, vector& num2){ vector ans; auto p1=num1.begin(), p2 = num2.begin(); while(p1!=num1.end() && p2!=num2.end()){ if(*p1 > *p2) ans.push_back(*p1),p1++; else if(*p1 maxNumber(vector& nums1, vector& nums2, int k) { int low = nums2.size()>k?0:k-nums2.size(); int high = nums1.size()>k?k:nums1.size(); vector maxNums1,maxNums2,res(k,0),tmp; for(int i=low;i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/":{"url":"My Solution/Medium/","title":"Medium","keywords":"","body":"Medium problem of Leetcode. By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/2 两数相加.html":{"url":"My Solution/Medium/2 两数相加.html","title":"2 两数相加","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 循环写法3.2. 递归写法1. 题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-two-numbers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 注意是数字在链表中逆序存储。 链表的基操。注意此题中不含表头结点。 3. 代码 3.1. 循环写法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *head=nullptr,*tmp=NULL; int num,carry=0,n1,n2; int i=0; while(1){ if(l1==nullptr&&l2==nullptr&&!carry) { tmp->next=nullptr; break; } coutval; n2=(l2==nullptr)?0:l2->val; if(l1) l1=l1->next; if(l2) l2=l2->next; num=n1+n2+carry; carry=num/10; if(!head){ head=new ListNode(num%10); tmp=head; }else{ tmp->next=new ListNode(num%10); tmp=tmp->next; } } return head; } void print(ListNode* head){ while(head!=NULL){ coutval); head=head->next; } } }; 3.2. 递归写法 看题解看到一种递归写法。但和上面一种解法相比而言，运行时间并没有改善。但代码很美。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return dfs(l1, l2, 0); } ListNode* dfs(ListNode* l, ListNode* r, int i) { if (!l && !r && !i) return nullptr; int sum = (l ? l->val : 0) + (r ? r->val : 0) + i; ListNode* node = new ListNode(sum % 10); node->next = dfs(l ? l->next : nullptr, r ? r->next : nullptr, sum / 10); return node; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/222 完全二叉树的结点个数.html":{"url":"My Solution/Medium/222 完全二叉树的结点个数.html","title":"222 完全二叉树的结点个数","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. BFS3.2. 二分+位运算3.2.1. 左开右开3.2.2. 左闭右开3.2.3. 左闭右闭1. 题目 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1∼2h1\\sim2^h1∼2h 个节点。 示例: 输入: 1 / \\ 2 3 / \\ / 4 5 6 输出: 6 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-complete-tree-nodes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 一开始用的BFS。 看题解竟然是二分+位运算，有点意思。记下来，以后整合一下。 利用完全二叉树的性质，求出最大深度h，结点的个数的范围即为[2h,2h+1−1][2^h,2^{h+1}-1][2h,2h+1−1] 在这个范围内二分即可。判定函数要利用位运算。偷张图： 3. 代码 3.1. BFS /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int countNodes(TreeNode* root) { if(!root) return 0; queue Q; int cnt = 0; TreeNode* tmp; Q.push(root); while(!Q.empty()){ tmp = Q.front(); Q.pop(); cnt ++; if(tmp->left) Q.push(tmp->left); if(tmp->right) Q.push(tmp->right); } return cnt; } }; 3.2. 二分+位运算 3.2.1. 左开右开 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool C(TreeNode* root, int h, int k){ k = k & ((1=0 ; --i){ if(k&(1right; else tmp = tmp->left; if(!tmp) return false; } return true; } int countNodes(TreeNode* root) { if(!root) return 0; int h = -1; TreeNode* tmp = root; while(tmp){ h++; tmp = tmp->left; } int L = (1> 1; if(C(root, h, mid)) L = mid; else R = mid; } return L; } }; 3.2.2. 左闭右开 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool C(TreeNode* root, int h, int k){ k = k & ((1=0 ; --i){ if(k&(1right; else tmp = tmp->left; if(!tmp) return false; } return true; } int countNodes(TreeNode* root) { if(!root) return 0; int h = -1; TreeNode* tmp = root; while(tmp){ h++; tmp = tmp->left; } int L = (1> 1; if(C(root, h, mid)) L = mid+1; else R = mid; } return L-1; } }; 3.2.3. 左闭右闭 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool C(TreeNode* root, int h, int k){ k = k & ((1=0 ; --i){ if(k&(1right; else tmp = tmp->left; if(!tmp) return false; } return true; } int countNodes(TreeNode* root) { if(!root) return 0; int h = -1; TreeNode* tmp = root; while(tmp){ h++; tmp = tmp->left; } int L = (1> 1; if(C(root, h, mid)) L = mid+1; else R = mid-1; } return R; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/3 无重复字符的最长子串.html":{"url":"My Solution/Medium/3 无重复字符的最长子串.html","title":"3 无重复字符的最长子串","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 尺取法，又称滑动窗口，实质为快慢指针 移动两端，推进区间的开头和结尾即可 利用哈希表辅助判断是否出现重复字符 3. 代码 class Solution { public: int lengthOfLongestSubstring(string s) { int l = 0, r = 0, res = 0; unordered_map mark; while(r By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/316 去除重复字母.html":{"url":"My Solution/Medium/316 去除重复字母.html","title":"316 去除重复字母","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 单调栈优化1. 题目 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同 示例 1： 输入：s = \"bcabc\" 输出：\"abc\" 示例 2： 输入：s = \"cbacdcbc\" 输出：\"acdb\" 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicate-letters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 这题与402 移掉K位数字类似 不同的是402总共去除K位数字，最后可以有重复的；而这题要去除所有的重复字母，未重复的字母不能去除。 因此这题不能简单的像402一样，每次去除第一个降序序列的首位，因为存在着这样的特殊情况：该首位字母只剩下这一个了，还有一些其他的问题。 这里举个例：absadfbs 如果按照之前的算法，那么：absadfbs => abadfbs => aadfbs => adfbs 很遗憾，最后的正确答案是abdfs 那么，如何修改 前面我们每次去除第一个降序序列的首位，原因是若要使得剩下的数字最小，需要保证靠前的数字尽可能小。 那么这里应该为对于最终返回的字符串，靠前的字符是在能保证其他字符至少能出现一次情况下的最小字符。 利用哈希表amt(key,value)，表示字符key出现的次数为value 对于字符s[i+1]，若小于等于字符s[i]，同时字符s[i]去掉后能保证还能出现至少一次，则去掉较大的字符s[i]，因为要使得靠前的字符尽量小。 对于字符s[i+1]，若在[0,i]间出现过，则去掉靠后的字符，因为上一个条件已经保证了前面出现过的相同的字符s[j]在一个更大的字符c的前面（*s[j] c*），如果去掉靠前的字符（*c*s[i+1]），很显然字典序（*s[j] c* >*c*s[i+1] ），因为c>s[i+1]=s[j]。 同样的，可以利用单调栈来优化 3. 代码 class Solution { public: string removeDuplicateLetters(string s) { unordered_map amt;//char c 's amount => int i for(auto &x:s) amt[x]++; for(int i=0;i=s[i+1] && amt[s[i]]>1){ amt[s[i]]--; s.erase(i,1); i-2>=0?i=i-2:i=-1; } } if(amt[s.back()]>1) s.pop_back(); return s; } }; 3.1. 单调栈优化 （这里用vector代替了栈） class Solution { public: string removeDuplicateLetters(string s) { unordered_map amt;//char c 's amount => int i for(auto &x:s) amt[x]++; vector res; for(int i=0;i1){ amt[res.back()]--; res.pop_back(); } res.push_back(s[i]); } s=\"\"; for(auto &x:res) s+=x; return s; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/328 奇偶链表.html":{"url":"My Solution/Medium/328 奇偶链表.html","title":"328 奇偶链表","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 输入: 1->2->3->4->5->NULL 输出: 1->3->5->2->4->NULL 示例 2: 输入: 2->1->3->5->6->4->7->NULL 输出: 2->3->6->7->1->5->4->NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 看到评论里 左脚踩右脚 笑死 3. 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* oddEvenList(ListNode* head) { if(!head||!head->next) return head; ListNode *odd = head, *evenHead = head->next, *even = evenHead; while(1){ if(!even->next){ odd->next = evenHead; break; } odd = odd->next = even->next; if(!odd->next){ even->next = nullptr; odd->next = evenHead; break; } even = even->next = odd->next; } return head; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/34 在排序数组中查找元素的第一个和最后一个位置.html":{"url":"My Solution/Medium/34 在排序数组中查找元素的第一个和最后一个位置.html","title":"34 在排序数组中查找元素的第一个和最后一个位置","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 10510^5105 −109-10^9−109 10910^9109 nums 是一个非递减数组 −109-10^9−109 10910^9109 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 利用find函数和upper_bound函数即可 3. 代码 class Solution { public: vector searchRange(vector& nums, int target) { int idx = find(nums.begin(), nums.end(), target) - nums.begin(); int len = nums.size(); if( idx == len ) return {-1,-1}; int last = upper_bound(nums.begin(), nums.end(), target) - nums.begin() -1; return {idx,last}; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/402 移掉K位数字.html":{"url":"My Solution/Medium/402 移掉K位数字.html","title":"402 移掉K位数字","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 输入: num = \"1432219\", k = 3 输出: \"1219\" 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 输入: num = \"10200\", k = 1 输出: \"200\" 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 输入: num = \"10\", k = 2 输出: \"0\" 解释: 从原数字移除所有的数字，剩余为空就是0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-k-digits 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 贪心 数字越靠前，比重越大；数字越大，比重越大。 每次找出第一个降序序列的首位去掉即可 利用栈维护单调性，降低时间复杂度 3. 代码 class Solution { public: string handle(string num){//去除前导0 int i=0; while(num[i]=='0') i++; if(i==num.size()) return \"0\"; return num.substr(i); } string removeKdigits(string num, int k) { for(int i=0;inum[i+1]) num.erase(i,1),i==0?i:i--,k--; else i++; } return handle(num); } }; 单调栈优化： （这里用vector代替了stack） class Solution { public: string handle(string num){//去除前导0 int i=0; while(num[i]=='0') i++; if(i==num.size()) return \"0\"; return num.substr(i); } string removeKdigits(string num, int k) { vector stk; for(auto &x:num){ while(!stk.empty() && k && stk.back()>x){ stk.pop_back(); k--; } stk.push_back(x); } while(k--) stk.pop_back(); string res; for(auto &x:stk) res+=x; return handle(res); } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/406 根据身高重建队列.html":{"url":"My Solution/Medium/406 根据身高重建队列.html","title":"406 根据身高重建队列","keywords":"","body":"1. 题目2. 解题思路2.1. 递归回溯2.2. 第一元素反向排序，第二元素正向排序3. 代码3.1. 超时代码3.2. 先排序再插入代码1. 题目 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人 示例 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 2.1. 递归回溯 一开始是按先k升序，再h升序排序，先排[5,0]，再排[7,0]，排第三个人的时候有3种选择，只能想到递归回溯了。然后就超时了。。 所以应该有其他算法。这种太暴力了。看到这样一段话： 一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。 2.2. 第一元素反向排序，第二元素正向排序 先按身高（k）从高到低排序，再按大于人数（h）从低到高排序 先排个高的，后面个矮的再怎么排，无论是排个高的前面还是后面，都不会影响到个高的h值。所以先按k降序排。那具体排哪儿呢，只需要排在第h+1个位置，使前面有h个不比他低的人就行。 如果身高相同，h大的人一定在h小的人后边。所以再按h升序排。 如此这般排完序后：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] => [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]] （下列计数从0开始计） 排第0个人[7,0] ：[ [7,0] ] 排第1个人[7,1]：[ [7,0], [7,1] ] 身高相同，h大的人排h小的人后边 排第2个人[6,1]：[ [7,0], [6,1], [7,1] ] 插入第1个位置，原来在第1个位置的[7,1]变成了第2个位置 排第3个人[5,0]：[ [5,0], [7,0], [6,1], [7,1] ] 插入第0个位置，原来后面的都后移1个位置 排第4个人[5,2]：[ [5,0], [7,0], [5,2], [6,1], [7,1] ] 插入第2个位置 排第5个人[4,4]：[ [5,0], [7,0], [5,2], [6,1], [4,4], [7,1] ] 插入第4个位置 3. 代码 3.1. 超时代码 class Solution { public: const static int MAXN = 1100+5; int num,book[MAXN]; bool flag = false; vector> ans; //已经排好了q-1位，将原队列第p个人排在新队列第q位是否满足条件 bool isok(vector>& people, int p, int q){//O(n) int cnt = 0;//前q-1位人比第q位身高大于等于的人数 for(int i=0;i=people[p][0]) cnt++; } return cnt==people[p][1]; } void dfs(vector>& people, int k){//排第k个人 if(k==num) { flag = true; return; } for(int i=0;i& a, vector& b){ if(a[1]!=b[1]) return a[1]> reconstructQueue(vector>& people) { num = people.size();//排队总人数 sort(people.begin(),people.end(),cmp); dfs(people,0); return ans; } }; 3.2. 先排序再插入代码 class Solution { public: bool static cmp(vector& a, vector& b){ if(a[0]!=b[0]) return a[0]>b[0]; else return a[1]> reconstructQueue(vector>& people) { sort(people.begin(),people.end(),cmp); vector > res; for(auto& x: people){ res.insert(res.begin()+x[1],x); } return res; } }; sort函数部分 lambda函数简化编程： class Solution { public: vector> reconstructQueue(vector>& people) { sort(people.begin(),people.end(),[](const vector& a, const vector& b){ if(a[0]!=b[0]) return a[0]>b[0]; else return a[1] > res; for(auto& x: people){ res.insert(res.begin()+x[1],x); } return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/452 用最少数量的箭引爆气球.html":{"url":"My Solution/Medium/452 用最少数量的箭引爆气球.html","title":"452 用最少数量的箭引爆气球","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4： 输入：points = [[1,2]] 输出：1 示例 5： 输入：points = [[2,3],[2,3]] 输出：1 提示： 0 10410^4104 points[i].length == 2 −231-2^{31}−231 xstartx_{start}xstart​ xendx_{end}xend​ 231−12^{31} - 1231−1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 经典区间问题，可用贪心： 先按右端点非降序排序，再每次找后面第一个区间的左端点大于该区间的右端点。 如下图，1、2号气球用第一只箭引爆，3、4号气球用第二支箭引爆。 3. 代码 class Solution { public: int findMinArrowShots(vector>& points) { sort(points.begin(),points.end(),[](const vector& a, const vector& b){ if(a[1]!=b[1]) return a[1]points[cur][1]){ sum++; cur=i; } } return sum; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/454 四数相加 II.html":{"url":"My Solution/Medium/454 四数相加 II.html","title":"454 四数相加 II","keywords":"","body":"1. 题目2. 解题思路3. 代码3.1. 排序后二分3.2. 哈希表1. 题目 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2282^{28}228 到 228−12^{28} - 1228−1 之间，最终结果不会超过 231−12^{31} - 1231−1 。 例如: 输入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出: 2 解释: 两个元组如下: (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/4sum-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 一看就知道要将A[i] + B[j] + C[k] + D[l] = 0转换为 A[i] + B[j] = - (C[k] + D[l])。 一开始排序后二分找超时了。后来换成哈希表过了。 3. 代码 3.1. 排序后二分 超时代码： 一开始也没想到这都超，N最大500，设M=N*N=250000，10的5次方，O(Mlog M)竟然都卡，常数也不是很大吧？ class Solution { public: int fourSumCount(vector& A, vector& B, vector& C, vector& D) { vector AB,CD; for(int i=0;i 3.2. 哈希表 class Solution { public: int fourSumCount(vector& A, vector& B, vector& C, vector& D) { unordered_map hashTable; for(int i=0;i By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/49 字母异位词分组.html":{"url":"My Solution/Medium/49 字母异位词分组.html","title":"49 字母异位词分组","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/group-anagrams 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 关键在于判断两个字符串是否相等，忽略字母相对位置。 可以利用哈希，这里可以选取哈希的方式为：H(S)=∑i=126num[i]∗i∗B26−iH(S) = \\sum\\limits_{i=1}^{26}num[i]*i*B^{26-i}H(S)=i=1∑26​num[i]∗i∗B26−i 其中，num[i]num[i]num[i]为小写字母ch的个数（ch-'a'+1） 3. 代码 #define ull unsigned long long const ull B = 1e9+7; vector num(27); class Solution { public: ull getHash(string str){ ull ans = 0; fill(num.begin(), num.end(), 0); for(auto &x:str) num[x-'a'+1]++; for(int i=1;i> groupAnagrams(vector& strs) { map record; vector> res; int len = strs.size(); for(int i=0; i empt; res.push_back(empt); record.emplace(hashValue, record.size()); } res[record[hashValue]].push_back(strs[i]); } return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/5 最长回文子串.html":{"url":"My Solution/Medium/5 最长回文子串.html","title":"5 最长回文子串","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 Manacher算法 3. 代码 将预处理后的字符串从1开始计数了，习惯使然 class Solution { public: string Manacher(string s){ string newstr; int len = s.size(), nlen = 2*s.size()+1, res = 1, resp = 0; newstr.resize(nlen); for(int i=1;i=1&&i+p[i]R) R=i+p[i],pos=i; //res：原字符串最长回文子串长度 //resp：原字符串最长回文子串 中心位置 ，偶数长度的为靠右位置 if(p[i]-1>res) res = p[i]-1, resp = (i-1)/2; } return s.substr(resp-res/2,res); } string longestPalindrome(string s) { return Manacher(s); } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/50 Pow x, n .html":{"url":"My Solution/Medium/50 Pow x, n .html","title":"50 Pow X N","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1: 输入: 2.00000, 10 输出: 1024.00000 示例 2: 输入: 2.10000, 3 输出: 9.26100 示例 3: 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 快速幂。当exponent小于0时，对base求倒数，对exponent求相反数。注意，当exponent为-2^31时，其相反数不能用int类型表示。 3. 代码 class Solution { public: double myPow(double x, int n) { long m=n; if(m>=1; } return res; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/62 不同路径.html":{"url":"My Solution/Medium/62 不同路径.html","title":"62 不同路径","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 向右 -> 向右 -> 向下 向右 -> 向下 -> 向右 向下 -> 向右 -> 向右 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n = 3 输出：6 提示： 1 2∗109 2 * 10^92∗109 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 动态规划经典问题。令dp[i][j]表示到(i,j)的路径条数，则dp[i][j] = dp[i-1][j] + dp[i][j-1]。处理一下特殊情况即可。 3. 代码 class Solution { public: int uniquePaths(int m, int n) { int dp[101][101]; memset(dp,0,sizeof(dp)); dp[0][0] = 1; for(int i=0; i=0) dp[i][j] += dp[i-1][j]; if(j-1>=0) dp[i][j] += dp[i][j-1]; } } return dp[m-1][n-1]; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/649 Dota2 参议院.html":{"url":"My Solution/Medium/649 Dota2 参议院.html","title":"649 Dota2 参议院","keywords":"","body":"1. 题目2. 解题思路2.1. 暴力2.2. 优化3. 代码3.1. 暴力3.2. 优化1. 题目 Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇) Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项： 禁止一名参议员的权利： 参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。 宣布胜利： 如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。 给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。 以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。 假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。 示例 1： 输入：\"RD\" 输出：\"Radiant\" 解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人 示例 2： 输入：\"RDD\" 输出：\"Dire\" 解释： 第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利 第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止 第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利 因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 提示： 给定字符串的长度在 [1, 10,000] 之间. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dota2-senate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 读懂题意之后，关键的问题就是禁止他人的权利这项权利该对谁用。 可以发现，这项权利应该对后面的对方阵营的第一个人用（当然，如果后方没有对面阵营的人的话，应该对前面的对方阵营的人用）。 以\"RDDR\"为例： 第一个R为了对自己的政党做出最好的策略，肯定会禁止掉第一个对方阵营D的权利； 这样，第一个D的权利就被禁止了，不能参加下一轮； 第二个D这时候有两个选择，要么禁止第一个R参加下一轮的权利，要么禁止掉第二个R参加下一轮的权利。这时候，很显然，第一个D已经用掉了禁止他人的权利，而第二个D还没用，为了对自己的政党做出最好的策略，所以肯定选择后者——禁止掉二个R参加下一轮的权利。 这样，第二个R的权利就被禁止了，不能参加下一轮； 下一轮开始，第一轮中的第一个R和第一个D进入第二轮，变成了“RD” R禁止掉D的权利。R进入第三轮。最后R方阵营胜利。 接下来是如何实现： 2.1. 暴力 按照上面的最优策略，可以用一个队列表示每轮的参议员，再求出每次进入下一轮的参议员。再判断这一轮是否只有一个阵营的人。 2.2. 优化 可以用两个队列分别存储两方参议员的位置，根据相对位置判断，若是可以禁止他人的权利，则将被禁止的人pop掉，行使权利的人将位置+n（总人数)后再加入队列即可。直至一方队列为空。 3. 代码 3.1. 暴力 class Solution { public: queue nextRound(queue& Q){//求出每次进入下一轮的参议员 int curR=0,curD=0;//目前有权的 queue que; while(!Q.empty()){ char x = Q.front();Q.pop(); if(x=='R'){ if(curD) curD--;//前面如果有对面阵营的人，这时候会被禁止掉权利 else { que.push('R');//暂时加入下一轮 if(Q.empty() && que.front()=='D') que.pop(); else curR++; } }else {//同上 if(curR) curR--; else { que.push('D'); if(Q.empty() && que.front()=='R') que.pop(); else curD++; } } } Q = que; while(!que.empty()){ que.pop(); } while(!Q.empty()){//如果有人的权利还没用掉，可以对前面出现的对方阵营的人使用 if(Q.front() == 'R'){ if(curD) curD--; else que.push('R'); }else{ if(curR) curR--; else que.push('D'); }Q.pop(); } return que; } char predict(queue Q){ queue que = nextRound(Q); Q = que; bool flag = true; char x = Q.front();Q.pop(); while(!Q.empty()){ if(Q.front() != x) { flag = false;break; }Q.pop(); } if(flag) return x; else return predict(que); } string predictPartyVictory(string senate) { int n = senate.size(); queue Q; for(auto &x:senate){ Q.push(x); } if(predict(Q) == 'R') return \"Radiant\"; else return \"Dire\"; } }; 这次实现太过臃肿了唉 3.2. 优化 class Solution { public: string predictPartyVictory(string senate) { int n = senate.size(); queue Radiant,Dire; for(int i=0;id) Dire.push(d+n); Radiant.pop(); Dire.pop(); } return Radiant.empty()?\"Dire\":\"Radiant\"; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/659 分割数组为连续子序列.html":{"url":"My Solution/Medium/659 分割数组为连续子序列.html","title":"659 分割数组为连续子序列","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。 如果可以完成上述分割，则返回 true ；否则，返回 false 。 示例 1： 输入: [1,2,3,3,4,5] 输出: True 解释: 你可以分割出这样两个连续子序列 : 1, 2, 3 3, 4, 5 示例 2： 输入: [1,2,3,3,4,4,5,5] 输出: True 解释: 你可以分割出这样两个连续子序列 : 1, 2, 3, 4, 5 3, 4, 5 示例 3： 输入: [1,2,3,4,4,5] 输出: False 提示： 输入的数组长度范围为 [1, 10000] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 贪心。 当 x 在数组中时，如果存在一个子序列以 x-1 结尾，长度为 k，则可以将 x 加入该子序列中，得到长度为 k+1的子序列。如果不存在以 x-1结尾的子序列，则必须新建一个只包含 x 的子序列，长度为 1。 对于数组中的元素 x，如果存在一个子序列以 x-1 结尾，则可以将 x 加入该子序列中。将 x 加入已有的子序列总是比新建一个只包含 x 的子序列更优，因为前者可以将一个已有的子序列的长度增加 1，而后者新建一个长度为 1 的子序列，而题目要求分割成的子序列的长度都不小于 3，因此应该尽量避免新建短的子序列。 引入哈希表count、seq count [i] = j 表示当前数字i在数组中还剩下j个没有放入满足要求的序列 seq [i] = j 表示长度为i的满足要求的序列已有j个 3. 代码 class Solution { public: bool isPossible(vector& nums) { unordered_map count,seq; for(auto &x: nums) count[x]++; for(auto &x: nums){ int cnt = count[x]; if(!cnt) continue; int preSeqCnt = seq[x-1]; if(preSeqCnt){//存在一个子序列以 x-1 结尾，则将 x 加入该子序列中 count[x]--; seq[x-1]--; seq[x]++; }else{//否则要新起一个子序列 int sufNum1cnt = count[x+1]; int sufNum2cnt = count[x+2]; if(sufNum1cnt && sufNum2cnt){ count[x]--; count[x+1]--; count[x+2]--; seq[x+2]++; }else return false; } } return true; } }; By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/767 重构字符串.html":{"url":"My Solution/Medium/767 重构字符串.html","title":"767 重构字符串","keywords":"","body":"1. 题目2. 解题思路3. 代码4. 知识点1. 题目 给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。 若可行，输出任意可行的结果。若不可行，返回空字符串。 示例 1: 输入: S = \"aab\" 输出: \"aba\" 示例 2: 输入: S = \"aaab\" 输出: \"\" 注意: S 只包含小写字母并且长度在[1, 500]区间内。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reorganize-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 这种贪心题找找规律就好了 可以发现，只要能将数量最多的字符隔开就好了。 设数量最多的字符数量为maxV，其他的字符总数量为sum，如果maxV>sum+1就说明无解，否则一定有解。 有解的话构造字符串，一种方式是： 每次将数量最多且与上一次的字符不同的字符加到返回字符串的最后一位 3. 代码 利用优先队列，动态的取出数量最多的字符 利用lambda函数对有限队列进行排序 做的有点麻烦了，可以优化 #define P pair class Solution { public: string reorganizeString(string S) { auto cmp = [](const P& a, const P& b){ if(b.second!=a.second) return a.second,decltype(cmp)> que(cmp); priority_queue,decltype(cmp)> Q(cmp); map table; for(auto &x: S) table[x]++; for(auto &x: table) { que.push(x); } int sum = 0,maxV = que.top().second; P tmp = que.top();que.pop(); Q.push(tmp); while(!que.empty()){ sum+=que.top().second; Q.push(que.top()); que.pop(); } if(sum+1 4. 知识点 利用lambda函数对priority_queue进行自定义排序时，要借助auto和decltype关键字： auto cmp = [](const P& a, const P& b){ if(b.second!=a.second) return a.second,decltype(cmp)> que(cmp); By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "},"My Solution/Medium/861 翻转矩阵后的得分.html":{"url":"My Solution/Medium/861 翻转矩阵后的得分.html","title":"861 翻转矩阵后的得分","keywords":"","body":"1. 题目2. 解题思路3. 代码1. 题目 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。 示例： 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]] 输出：39 解释： 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]] 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/score-after-flipping-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2. 解题思路 对于行来说，越靠前比重越大，只要每行的最前一个数为0，就将它整行翻转。（2n>2n−1+2n−2+⋯+12^n > 2^{n-1}+2^{n-2}+\\dots+12n>2n−1+2n−2+⋯+1 对于列来说，每一列的每个数比重一样，看0的数量和1的数量即可，若0的数量大于1的数量就整列翻转。 最后按要求求和。 3. 代码 class Solution { public: int matrixScore(vector>& A) { int row = A.size(), col = row==0?0:A[0].size(); vector cnt(col,0); //行 for(int i=0; i(float)row/2) for(int j=0; j By wangzhebufangqi，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2020-12-14 12:42:36 "}}